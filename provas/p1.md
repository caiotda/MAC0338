### Lista 10

(1,0) 1) Suponha que n é um número natural positivo. 

É verdade que ⌊n/2⌋ = ⌈½ (n−1)⌉? É verdade que ⌈n/2⌉ − 1 = ⌊½ (n−1)⌋? Justifique.

Não use a tecla `tab`.



Como n é natural positivo, se conseguirmos provar as afirmações para n par e n ímpar, a afirmação está provada pois provamos para todo caso de n.

Parte1:

Para n  par, vale que

piso(n/2) =  n/2

teto(1/2 (n-1)) = 1/2 * n = n/2

Para n ímpar:

piso(n/2) = (n-1)/2

teto(1/2 * (n-1)) = 1/2 * (n-1) = (n-1)/2

Como n é natural, está provado que a afirmação 1 vale.



Parte 2:



Para n par:

teto(n/2) - 1 = n/2 - 1

piso(1/2 * (n-1)) = 1/2 * (n-2) = (n-2)/2 = n/2 - 1



Para n ímpar:

teto(n/2) - 1 = (n+1)/2 - 1 = (n+1 - 2)/2 = 1/2 * (n-1)

piso(1/2 * (n-1)) = 1/2 * (n-1)



***

(2,0) 2) Qual a inversa da função 3 ^lg n ? (Essa função está definida para todo número natural positivo n.) Justifique sua resposta.



Vamos adotar a abreviatura y = 3^lg n. Vamos isolar n e assim obter a função inversa:

lg y = lg (3^lg n)

lg y = lg n * lg 3

lg n = lg y / lg 3

n = 2^(lg y / lg 3)

n = y ^ (lg 2 / lg 3)

n = y ^ log_3{2}


Como y ^ log_3{2} = n, vale que n ^ log_3{2} é a função inversa de 3^lg n

***

(1,0) 3) Suponha que F(n) > n e G(n) > n para todo n ≥ 1. É verdade que F está em Ο(G) se e somente se existem números positivos c, n0 e n ≥ n0 tais que F(n) ≤ c G(n). Justifique.

Não. N deve ser maior igual a n0 para todo n. De acordo com a definição dada, se encontrarmos números positivos c e n0, sendo que n0 >= algum n, então isso implicaria que F está em O(G), o que não é verdade. Devemos encontrar n0 tal que n >=n0 *para todo n*.

***

(6,0) 4)

Escreva um algoritmo de divisão e conquista para encontrar o valor de um elemento máximo de um vetor A[p .. r] de números inteiros.

Parte 2: Seja C(n) o número de comparações entre elementos do vetor que seu algoritmo faz ao receber um vetor de n elementos. Escreva a recorrência que C(n) satisfaz e especifique o valor inicial.



Parte 3: Exiba a solução (exata) da recorrência e prove por indução que essa solução está correta.



Parte1: 

``` ol
max(A, n)
1. se n = 1
2.    devolva A[1]
3. candidato = max(A, n-1)
4. se candidato > A[n]
5.    devolva candidato
6. devolva A[n]
```

Parte2:

C(n) = C(n-1) + 1

C(1) = 0

Parte3: 

Desenrolando a recorrência, temos:

C(n) = C(n-1) + 1

= (C(n-2) + 1) + 1 = C(n-2) + 2

= (C(n-3) + 1) + 2 = C(n-3) + 3

...

= (C(1) + 1) + n-2 = C(1) + n-1; Mas C(1) = 0, logo



C(n) = n-1 

Agora vamos provar por indução que C(n) = n-1 vale para n >= 1



Base (n=1)

C(1) = 0 = 1 - 1 = 0

Agora vamos supor como hipótese de indução que C(n-1) = (n-1) - 1 vale. Temos:

C(n-1)  = n-1 -1 = n-2;

C(n-1) + 1 = n-2 + 1

C(n-1) + 1 = n - 1; Mas C(n) = C(n-1) + 1, logo

C(n) = n - 1.

Isso conclui a prova por indução de que C(n) = n-1 para n >= 1.

***

(6,0) 5 )Seja S uma função definida sobre os números naturais maiores que ou iguais a 1. Suponha que S(1) = 11 e S(n) = n + S(⌊n/2⌋) para todo n ≥ 2. Prove que S(n) ≥ 2n + 9 − lg n para todo n ≥ 1.





***

(4,0) 6)



Considere o algoritmo MÁXIMO, que calcula o valor de um elemento máximo de um vetor A[1 .. n]. Suponha que A[1 .. n] é uma permutação aleatória uniforme de 1 .. n e seja X a variável aleatória que dá o número de execuções da atribuição max := A[i] no algoritmo. Quanto vale Pr[X = n]? 
 Parte 2: Quanto vale Pr[X = 1]?



Parte 1

De todas as n! permutações igualmente prováveis, só há 1 permutação na qual X = n. Assim, Pr[X = n] = 1/n!

Parte2

X = 1 é um evento associado às instâncias do problema no qual o máximo está em A[1]. Assim, todas permutações nas quais o máximo está fixado em A[1] são validas. Portanto, Pr[X = n] = (n-1)!/n!, logo, Pr[X = n] = 1/n



