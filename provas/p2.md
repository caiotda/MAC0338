### Prova 2 - Análise de algoritmos

**(2,5) Questão 1**

Considere os algoritmos Algo-A e Algo-B abaixo.

Parte 1: que números Algo-A e Algo-B devolvem ao receber um número natural n? Justifique.

Parte2: Calcule o consume de tempo de cada um dos algoritmos em função de n. Para i = 1,2,4, suponha que cada execução da linha i do código consome 1 unidade de tempo. Justifique sua resposta por indução matemática.

Parte 3: Traduza o consume de tempo de cada algoritmo para notação $\Theta$ e justifique a tradução.



``` 
Algo-A(n)
1. se n = 0
2.		devolva 0
3. x:= 2 - Algo-A(n-1) + 4
4. devolva x
```



``` 
Algo-B(n)
1. se n = 0
2. 		devolva 0
3. x := Algo-B(n-1) + Algo-B(n-1) + 4
4. devolva x
```

Não use a tecla Tab.

***

**(1,5) Questão 2**

Prove que depois de cada execução da operação Union-3, para cada vértice v, o valor de alt[v] é igual à altura do vértice v. Não use a tecla tab.

```
Union-3 (r, s)  ▷ union-by-rank; r ≠ s
1 se alt[r] > alt[s]
2 	chefe[s] := r
3 senão chefe[r] := s
4 	se alt[r] = alt[s]
5 		alt[s] := alt[s] + 1 
```

Vamos supor que alt[v] representa a altura do vértice v ao início da execução da operação Union-3(u, v). Se alt[u] > alt[v] ou alt[u] < alt[v], a operação não altera alt[v] então não há o que se provar neste caso.



Então basta provar que, se alt[u] = alt[v], então H = alt[v] + 1, onde H é a altura do vértice v ao fim da execução da operação union(u, v).

Vamos definir o conjunto de filhos de v como o conjunto de vértices cujo chefe é v.

 Vamos chamar de folha qualquer vértice que não é chefe de ninguém. Um caminho é qualquer sequência de vértices da forma (u,  chefe[u], chefe[chefe[u]],  … ).

A altura de um vértice v é definida como o caminho mais longo de qualquer folha de v até v. Alternativamente, podemos definir a altura de um vértice v como a altura máxima de um dos seus filhos mais 1.

Como consequência dessa definição, vale que a altura máxima de um filho de v no início da operação union(u,v) é alt[v] - 1.

Adote a abreviatura H' para a alt[v] antes da operação ser aplicada. Aplique a operação e analise o caso que alt[u] = alt[v]. Como alt[x] > 0  para todo vértice x, vale que alt[u] > H' - 1. Consequentemente, u possui a altura máxima dos filhos de v. Assim, H = alt[u] + 1; mas alt[u] = alt[v], logo, H = alt[v] + 1, o que é feito na linha 5 do algoritmo union(u,v).



Assim, fica provado que ao fim da operação de union(u, v)  vale que alt[v] representa a altura do vértice v.

***



**(1,5) Questão 3**

Parte 1: Escreva um algoritmo Algo que chama o algoritmo MST-Kruskal para resolver o seguinte problema: Dado um grafo conexo G e um vetor p de pesos indexado pelas arestas de G, encontrar uma árvore geradora de G que tenha peso máximo

Parte 2: Prova que seu algoritmo está correto.

Não use a tecla tab.



***

**(1,5) Questão 4**



Considere o problema de rearranjar em ordem crescente um vetor com 5 elementos distintos dois a dois. Considere todos os possíveis algoritmos para o problema que sejam baseados em comparações entre elementos do vetor. 

Qual o número mínimo de comparações que um algoritmo deve fazer (no pior caso) para resolver o problema? Justfique.

***

5 * log(5)/2;

Todo algoritmo de ordenação baseado em comparação pode ser representado por uma árvore de decisão, onde cada nó da árvore é uma comparação. Seja h a altura da árvore e n o número de elementos que podem ser comparados. Como uma árvore tem no máximo 2^h folhas e pelo menos n! folhas, vale que:

2^h >= n!

logo

h >= lg (n!)



Vamos mostrar que lg(n!) >= 1/2 n lg(n)



Seja i um natural tal que 0<= i <= n-1. Mostrarei primeiro que (n − i) (i + 1) >= n.

n-1 >= i

n >= i + 1

ni >= i^2 + i

ni -i^2 i- >= 0

ni -i^2 -i + n >= n

(n-i)*(i+1) >= n

Usando o fato provado acima, irei mostrar que (n!)^2 >= n^n



n!^2 = produtorio _{0 <= i <= n - 1}(i+1) * (n - i)

Como 0 <= i <= n -1, vale que

produtorio _{0 <= i <= n - 1}(i+1) * (n - i) >= produtorio _{0 <= i <= n - 1} n = n^n

portanto

n!^2 >= n^n



Logo, n! >= n^n/2. Tomando o log da desigualdade:

lg(n!) >= lg(n^n/2)

lg(n!) >= n/2 * lg (n)

Assim

h >= n/2 lg n

isso prova que a altura de uma árvore de decisão é, no mínimo, n/2 lg n, portanto, o número de comparações de qualquer algoritmo de decisão baseado em comparações é no mínimo n/2 lg n. No nosso caso, n = 5, portanto, o número de comparações mínimo é 5/2 lg (5).



***

**(1,5) Questão 5**



Suponha dado um algoritmo Soma para o problema Subset-Sum.

Parte 1: Use esse algoritmo para escrever um algoritmo Algo que resolva o seguinte problema: Dado um vetor p[1..n] de números naturais, decidir se existe uma partição (J, K) de {1, ..., n} tal que 
$$
\sum_{j \in J}p[j] = \sum_{k \in K}p[k]
$$
Parte 2: Mostre que seu algoritmo Algo está correto.



Não use a tecla tab.



```
Algo(p, n)
1. soma := 0
2. para i :=1 até n
3.     soma := soma + p[i]
4. se soma mod 2 != 0
5.     devolva 0
6. devolva Soma(p, n, soma/2)
```

Parte 2:



Queremos provar que existem duas partições J, K tal que soma _{j em J} p[j] = soma _{k em K} p[k]; Primeiramente, vamos adotar as abreviaturas: 



p1 =  somatorio _{j em J} p[j]

p_n = somatorio_{j não em J} p[j]

p2 = p[j] = somatorio _{k em K} p[k]

pt = p[j] = somatorio_{i em n} p[i]

Como p1 = p2 e p1 + p2 = pt, vale que p1 = p2 = pt / 2. Como p é um vetor de naturais, então tanto p1, p2, p_n e pt pertencem aos naturais. Naturalmente, se pt for ímpar, não há como existirem duas partições com essas propriedades, pois pt/2 não é natural.

Agora, se pt for par, basta encontrar uma partição cuja soma é pt/2. Como o algoritmo Soma resolve o problema do subset sum, ele é capaz de verificar se tal partição existe. Suponha que o algoritmo Soma verifique que tal partição existe. Adotemos a abreviatura J para se referir a tal partição. Como somatorio _{j em J} p[y] = Pt/2, então vale que p_n = Pt/2. Mas j não em J é uma partição de {1...n} cuja soma é igual a soma dos elementos em J. Então existem duas partições de soma igual e nosso algoritmo verifica corretamente que existem duas partições.



Se Soma não encontra uma partição com peso Pt/2, não há duas partições com soma igual pois a soma dos valores das duas partições necessariamente deve valer Pt.



**(1,5) Questão 6** 



Considere o problema de decisão INDEPENDENTE-GRANDE.

Parte 1: Prove que uma instância (G, k) do problema tem solução "não" se e somente se G tem uma cobertura mínima com mais que  n - k vértices.

Parte2: Discuta se sua resposta para parte 1 coloca o problema INDEPENDENTE-GRANDE na classe coNP

Não use a tecla tab